name: Deploy to AWS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: us-east-1
  ECR_API_REPO: proyecto1-api
  ECR_WORKER_REPO: proyecto1-worker
  ECR_FRONTEND_REPO: proyecto1-frontend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | \
            docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: ./api
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_API_REPO }}:${{ github.sha }}
            ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_API_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Worker image
        uses: docker/build-push-action@v5
        with:
          context: ./worker
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_WORKER_REPO }}:${{ github.sha }}
            ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_WORKER_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./front
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_FRONTEND_REPO }}:${{ github.sha }}
            ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_FRONTEND_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  migrate-database:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: sudo apt-get install -y postgresql-client

      - name: Run database migrations
        env:
          PGPASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Run migrations (ignore errors for existing tables)
          psql -h ${{ secrets.RDS_ENDPOINT }} -U postgres -d proyecto_1 -f db/001_create_user_table.sql || true
          psql -h ${{ secrets.RDS_ENDPOINT }} -U postgres -d proyecto_1 -f db/002_create_video_table.sql || true
          psql -h ${{ secrets.RDS_ENDPOINT }} -U postgres -d proyecto_1 -f db/003_add_is_public_to_videos.sql || true
          psql -h ${{ secrets.RDS_ENDPOINT }} -U postgres -d proyecto_1 -f db/004_create_votes_table.sql || true
          psql -h ${{ secrets.RDS_ENDPOINT }} -U postgres -d proyecto_1 -f db/005_create_player_rankings_view.sql || true

  build-frontend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: front/package-lock.json

      - name: Install dependencies
        run: |
          cd front
          npm ci

      - name: Build frontend
        run: |
          cd front
          npm run build

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: front/dist

  deploy:
    needs: [build-and-push, migrate-database, build-frontend]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: front/dist

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Web Server (ASG)
        run: |
          # Get all instance IDs from the Auto Scaling Group
          ASG_NAME="${{ secrets.ASG_NAME }}"
          if [ -z "$ASG_NAME" ]; then
            ASG_NAME="proyecto1-web-server-asg"
          fi
          
          echo "Finding instances in ASG: $ASG_NAME"
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'AutoScalingGroups[0].Instances[*].InstanceId' \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ] || [ "$INSTANCE_IDS" = "None" ]; then
            echo "‚ùå No instances found in ASG. Waiting for instances to be ready..."
            exit 1
          fi
          
          echo "Found instances: $INSTANCE_IDS"
          
          # Deploy to each instance using SSM
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to instance: $INSTANCE_ID"
            
            # Upload nginx config via SSM
            echo "Uploading nginx config..."
            # Base64 encode the nginx config file
            NGINX_B64=$(cat nginx/nginx.aws.conf | base64 -w 0)
            
            # Upload nginx config using SSM with base64 content embedded
            NGINX_UPLOAD_CMD_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=[
                'mkdir -p /home/ec2-user/proyecto1',
                'echo \"$NGINX_B64\" | base64 -d > /home/ec2-user/proyecto1/nginx.aws.conf',
                'chmod 644 /home/ec2-user/proyecto1/nginx.aws.conf',
                'test -f /home/ec2-user/proyecto1/nginx.aws.conf && echo \"Nginx config uploaded successfully\" || echo \"Nginx config upload failed\"'
              ]" \
              --parameters "environment=[\"NGINX_B64=$NGINX_B64\"]" \
              --region ${{ env.AWS_REGION }} \
              --query 'Command.CommandId' \
              --output text)
            
            # Wait for nginx config upload to complete
            if [ -n "$NGINX_UPLOAD_CMD_ID" ]; then
              echo "Waiting for nginx config upload..."
              aws ssm wait command-executed \
                --command-id "$NGINX_UPLOAD_CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} || echo "Warning: Nginx config upload may have failed"
              
              # Verify upload succeeded
              UPLOAD_STATUS=$(aws ssm get-command-invocation \
                --command-id "$NGINX_UPLOAD_CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --query 'Status' \
                --output text)
              
              if [ "$UPLOAD_STATUS" != "Success" ]; then
                echo "‚ö†Ô∏è  Nginx config upload failed, but continuing deployment..."
                aws ssm get-command-invocation \
                  --command-id "$NGINX_UPLOAD_CMD_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region ${{ env.AWS_REGION }} \
                  --query 'StandardErrorContent' \
                  --output text || true
              else
                echo "‚úÖ Nginx config uploaded successfully"
              fi
            fi
            
            # Send deployment command via SSM
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=[
                'set -e',
                'aws ecr get-login-password --region ${{ env.AWS_REGION }} | sudo docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}',
                'sudo docker stop proyecto1-api-aws || true',
                'sudo docker rm proyecto1-api-aws || true',
                'sudo docker pull ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_API_REPO }}:latest',
                'sudo docker run -d --name proyecto1-api-aws --restart unless-stopped --network host -e DB_HOST=${{ secrets.RDS_ENDPOINT }} -e DB_PORT=5432 -e DB_NAME=proyecto_1 -e DB_USER=postgres -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} -e DB_SSL_MODE=require -e S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }} -e SQS_QUEUE_NAME=${{ secrets.SQS_QUEUE_NAME }} -e JWT_SECRET=${{ secrets.JWT_SECRET }} -e AWS_DEFAULT_REGION=${{ env.AWS_REGION }} ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_API_REPO }}:latest',
                'sudo docker stop proyecto1-frontend-aws || true',
                'sudo docker rm proyecto1-frontend-aws || true',
                'sudo docker pull ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_FRONTEND_REPO }}:latest',
                'sudo docker run -d --name proyecto1-frontend-aws --restart unless-stopped --network host ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_FRONTEND_REPO }}:latest',
                'sudo docker stop proyecto1-nginx-aws || true',
                'sudo docker rm proyecto1-nginx-aws || true',
                'sudo docker run -d --name proyecto1-nginx-aws --restart unless-stopped --network host -v /home/ec2-user/proyecto1/nginx.aws.conf:/etc/nginx/nginx.conf:ro nginx:alpine',
                'sudo docker ps'
              ]" \
              --parameters "executionTimeout=['3600']" \
              --parameters "workingDirectory=['/home/ec2-user']" \
              --region ${{ env.AWS_REGION }} \
              --query 'Command.CommandId' \
              --output text)
            
            echo "Command ID: $COMMAND_ID"
            
            # Wait for command to complete
            echo "Waiting for deployment to complete..."
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} || true
            
            # Check command status
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region ${{ env.AWS_REGION }} \
              --query 'Status' \
              --output text)
            
            if [ "$STATUS" != "Success" ]; then
              echo "‚ùå Deployment failed on instance $INSTANCE_ID with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region ${{ env.AWS_REGION }} \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            else
              echo "‚úÖ Deployment successful on instance $INSTANCE_ID"
            fi
          done
          
          echo "‚úÖ All instances deployed successfully!"

      - name: Restart Worker
        run: |
          ssh -i key.pem -o StrictHostKeyChecking=no \
            ec2-user@${{ secrets.WORKER_IP }} << 'ENDSSH'
            # Login to ECR
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | sudo docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
            
            # Stop and remove existing worker container
            sudo docker stop proyecto1-worker-aws || true
            sudo docker rm proyecto1-worker-aws || true
            
            # Pull latest image
            sudo docker pull ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_WORKER_REPO }}:latest
            
            # Start new worker container with fixed AWS credentials
            sudo docker run -d --name proyecto1-worker-aws --restart unless-stopped \
              --network host \
              -e DB_HOST=${{ secrets.RDS_ENDPOINT }} \
              -e DB_PORT=5432 \
              -e DB_NAME=proyecto_1 \
              -e DB_USER=postgres \
              -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
              -e DB_SSL_MODE=require \
              -e S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }} \
              -e SQS_QUEUE_NAME=${{ secrets.SQS_QUEUE_NAME }} \
              -e AWS_DEFAULT_REGION=us-east-1 \
              ${{ secrets.ECR_REGISTRY }}/${{ env.ECR_WORKER_REPO }}:latest
            
            # Show running containers
            sudo docker ps
          ENDSSH

      - name: Health Check
        run: |
          # Get ALB DNS name from secret or AWS CLI
          ALB_DNS="${{ secrets.ALB_DNS_NAME }}"
          
          if [ -z "$ALB_DNS" ]; then
            echo "‚ö†Ô∏è  ALB_DNS_NAME secret not set. Attempting to get from AWS..."
            # Try to get ALB DNS from AWS CLI using the ASG name
            ASG_NAME="${{ secrets.ASG_NAME }}"
            if [ -z "$ASG_NAME" ]; then
              ASG_NAME="proyecto1-web-server-alb"
            fi
            
            # Get ALB DNS name from AWS
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --region ${{ env.AWS_REGION }} \
              --query "LoadBalancers[?contains(LoadBalancerName, 'proyecto1-web-server-alb')].DNSName" \
              --output text | head -n 1)
          fi
          
          if [ -z "$ALB_DNS" ]; then
            echo "‚ùå Could not determine ALB DNS name."
            echo "   Please set ALB_DNS_NAME secret in GitHub Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "   Get the value with: terraform output -raw alb_dns_name"
            exit 1
          fi
          
          echo "Checking health at: http://$ALB_DNS"
          echo "Waiting for instances to be healthy..."
          sleep 30
          
          # Retry health check up to 3 times
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES: Checking API health through ALB..."
            if curl -f -s --max-time 10 http://$ALB_DNS/api/health > /dev/null; then
              echo "‚úÖ API health check passed"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Health check failed, retrying in 15 seconds..."
                sleep 15
              else
                echo "‚ùå API health check failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          echo "Checking Frontend..."
          if curl -f -s --max-time 10 http://$ALB_DNS > /dev/null; then
            echo "‚úÖ Frontend check passed"
          else
            echo "‚ö†Ô∏è  Frontend check failed, but API is working"
          fi
          
          echo "‚úÖ Deployment successful!"
          echo "üåê Application URL: http://$ALB_DNS"
